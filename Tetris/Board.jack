/**
 * Implements the Square game.
 * This simple game allows the user to move a black square around
 * the screen, and change the square's size during the movement.
 * When the game starts, a square of 30 by 30 pixels is shown at the
 * top-left corner of the screen. The user controls the square as follows.
 * The 4 arrow keys are used to move the square up, down, left, and right.
 * The 'z' and 'x' keys are used, respectively, to decrement and increment
 * the square's size. The 'q' key is used to quit the game.
 */
class Board {
    field Array minos;
    field int c, r;
    field int i;
    field Mino mino;


    /** Constructs a new square game. */
    constructor Board new() {
        let i = 0;
        let minos = Array.new(200);
        while (i < 200) {
            let minos[i] = null;
            let i = i + 1;
        }

        do Screen.setColor(true);
        do Screen.drawLine(30, 30, 135, 30);
        do Screen.drawLine(30, 30, 30, 235);
        do Screen.drawLine(135, 30, 135, 235);
        do Screen.drawLine(30, 235, 135, 235);
        do Screen.drawLine(32, 32, 133, 32);
        do Screen.drawLine(32, 32, 32, 233);
        do Screen.drawLine(133, 32, 133, 233);
        do Screen.drawLine(32, 233, 133, 233);
        return this;
    }

    method int processBoardClear() {
        var int clearCount;
        var int srcindex;
        var boolean isClear;

        let clearCount = 0;
        let srcindex = 0;

        let r = 19;
        while (r > -1) 
        {
            let isClear = false;
            let c = 0;
            while (c < 10)
            {
                if (hasMino(c, r))
                {
                    let c = c + 1;
                }
                else
                {
                    let c = 11;
                }
            }

            if (c = 10) {
                let isClear = true;
                let clearCount = clearCount + 1;
            }

            let c = 0;
            while (c < 10)
            {
                let srcindex = (r * 10) + c; 
                let mino = minos[srcindex];
                if (hasMino(c, r)) {
                    do mino.show(33 + (c * 10), 33 + (r * 10), false);
                    if (isClear)
                    {
                        do mino.dispose();
                        let minos[srcindex] = null;
                    }
                    else
                    {
                        let minos[((r + clearCount) * 10) + c] = mino;
                        if (clearCount > 0)
                        {
                            let minos[srcindex] = null;
                        }
                        do mino.show(33 + (c * 10), 33 + ((r + clearCount) * 10), true);
                    }
                }
                let c = c + 1;
            }

            let r = r - 1;
        }

        return clearCount;
    }

    method boolean isColliding(int x, int y, Tetromino tetromino) {
        var int index;
        var int size;

        let c = x;
        let r = y;
        let size = tetromino.getSize();

        while (r < (y + size)) {
            while (c < (x + size)) {
                if (tetromino.hasMino(c - x, r - y)) {
                    if (isValidPos(c, r))
                    {
                        if (hasMino(c, r)) {
                            return true;
                        }
                    }
                    else
                    {
                        return true;
                    }
                }
                let c = c + 1;
            }
            let c = x;
            let r = r + 1;
        }
        return false;
    }

    method void addMino(int x, int y, Mino amino) {
        let minos[(y * 10) + x] = amino;
        return;
    }

    method boolean isValidPos(int x, int y) {
        if ((x < 0) | (x > 9) | (y < 0) | (y > 19)) {
            return false;
        }
        return true;
    }

    method boolean hasMino(int x, int y) {
        if (minos[(y * 10) + x] = null)
        {
            return false;
        }
        return true;
    }

    /** Disposes this game. */
    method void dispose() {
        let i = 0;
        while (i < 200) {
            let mino = minos[i];
            if (~(mino = null)) {
                do mino.dispose();
            }
            let i = i + 1;
        }
        do minos.dispose();
        do Memory.deAlloc(this);
        return;
    }
}



